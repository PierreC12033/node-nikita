// Generated by CoffeeScript 2.5.1
// # `nikita.file`

// Write a file or a portion of an existing file.

// ## Callback parameters

// * `err`   
//   Error object if any.
// * `status`   
//   Indicate file modifications.

// ## Implementation details

// Internally, this function uses the "chmod" and "chown" function and, thus,
// honor all their options including "mode", "uid" and "gid".

// ## Diff Lines

// Diff can be obtained when the options "diff" is set to true or a function. The
// information is provided in two ways:

// * when `true`, a formated string written to the "stdout" option.
// * when a function, a readable diff and the array returned by the function 
//   `diff.diffLines`, see the [diffLines] package for additionnal information.

// ## More about the `append` option

// The `append` option allows more advanced usages. If `append` is "null", it will
// add the value of the "replace" option at the end of the file when no match
// is found and when the value is a string.

// Using the `append` option conjointly with the `match` and `replace` options gets
// even more interesting. If append is a string or a regular expression, it will
// place the value of the "replace" option just after the match. Internally, a
// string value will be converted to a regular expression. For example the string
// "test" will end up converted to the regular expression `/test/mg`.

// ## Replacing part of a file using from and to markers

// ```js
// require('nikita')
// .file({
//   content: 'here we are\n# from\nlets try to replace that one\n# to\nyou coquin',
//   from: '# from\n',
//   to: '# to',
//   replace: 'my friend\n',
//   target: scratch+'/a_file'
// }, function(err, {status}){
//   // '# here we are\n# from\nmy friend\n# to\nyou coquin'
// })
// ```

// ## Replacing a matched line by a string

// ```js
// require('nikita')
// .file({
//   content: 'email=david(at)adaltas(dot)com\nusername=root',
//   match: /(username)=(.*)/,
//   replace: '$1=david (was $2)',
//   target: scratch+'/a_file'
// }, function(err, {status}){
//   // '# email=david(at)adaltas(dot)com\nusername=david (was root)'
// })
// ```

// ## Replacing part of a file using a regular expression

// ```js
// require('nikita')
// .file({
//   content: 'here we are\nlets try to replace that one\nyou coquin',
//   match: /(.*try) (.*)/,
//   replace: ['my friend, $1'],
//   target: scratch+'/a_file'
// }, function(err, {status}){
//   // '# here we are\nmy friend, lets try\nyou coquin'
// })
// ```

// ## Replacing with the global and multiple lines options

// ```js
// require('nikita')
// .file({
//   content: '#A config file\n#property=30\nproperty=10\n#End of Config',
//   match: /^property=.*$/mg,
//   replace: 'property=50',
//   target: scratch+'/a_file'
// }, function(err, {status}){
//   // '# A config file\n#property=30\nproperty=50\n#End of Config'
// })
// ```

// ## Appending a line after each line containing "property"

// ```js
// require('nikita')
// .file({
//   content: '#A config file\n#property=30\nproperty=10\n#End of Config',
//   match: /^.*comment.*$/mg,
//   replace: '# comment',
//   target: scratch+'/a_file',
//   append: 'property'
// }, function(err, {status}){
//   // '# A config file\n#property=30\n# comment\nproperty=50\n# comment\n#End of Config'
// })
// ```

// ## Multiple transformations

// ```js
// require('nikita')
// .file({
//   content: 'username: me\nemail: my@email\nfriends: you',
//   write: [
//     {match: /^(username).*$/mg, replace: '$1: you'},
//     {match: /^email.*$/mg, replace: ''},
//     {match: /^(friends).*$/mg, replace: '$1: me'}
//   ],
//   target: scratch+'/a_file'
// }, function(err, {status}){
//   // 'username: you\n\nfriends: me'
// })
// ```

// ## On config
var handler, on_action, path, schema, utils;

on_action = function({config}) {
  if (!((config.source || (config.content != null)) || config.replace || (config.write != null))) {
    // Validate parameters
    throw Error('Missing source or content');
  }
  if (config.source && config.content) {
    throw Error('Define either source or content');
  }
  if (!config.target) {
    throw Error('Missing target');
  }
  if (config.content) {
    if (typeof config.content === 'number') {
      config.content = `${config.content}`;
    } else if (Buffer.isBuffer(config.content)) {
      config.content = config.content.toString();
    }
  }
  if (typeof config.backup_mode === 'string') {
    config.backup_mode = parseInt(config.backup_mode, 8);
  }
  if (typeof config.mode === 'string') {
    return config.mode = parseInt(config.mode, 8);
  }
};

// ## Schema
schema = {
  // name: '@nikitajs/core/lib/file'
  type: 'object',
  properties: {
    'append': {
      oneOf: [
        {
          type: 'string'
        },
        {
          type: 'boolean'
        },
        {
          instanceof: 'RegExp'
        }
      ],
      default: false,
      description: `Append the content to the target file. If target does not exist, the
file will be created.`
    },
    'backup': {
      oneOf: [
        {
          type: 'string'
        },
        {
          typeof: 'boolean'
        }
      ],
      description: `Create a backup, append a provided string to the filename extension or
a timestamp if value is not a string, only apply if the target file
exists and is modified.`
    },
    'backup_mode': {
      type: 'integer',
      default: 0o0400,
      description: `Backup file mode (permission and sticky bits), defaults to \`0o0400\`,
in the  form of \`{mode: 0o0400}\` or \`{mode: "0400"}\`.`
    },
    'content': {
      oneOf: [
        {
          type: 'string'
        },
        {
          typeof: 'function'
        }
      ],
      description: `Text to be written, an alternative to source which reference a file.`
    },
    'context': {
      type: 'object',
      description: `Context provided to the template engine.`
    },
    'diff': {
      typeof: 'function',
      description: `Print diff information, pass a readable diff and the result of [jsdiff.diffLines][diffLines] as
arguments if a function, default to true.`
    },
    'eof': {
      oneOf: [
        {
          type: 'string'
        },
        {
          type: 'boolean'
        }
      ],
      description: `Ensure the file ends with this charactere sequence, special values are
'windows', 'mac', 'unix' and 'unicode' (respectively "\r\n", "\r", "\n",
"\u2028"), will be auto-detected if "true", default to false or "\n" if
"true" and not detected.`
    },
    'encoding': {
      type: 'string',
      default: 'utf8',
      description: `Encoding of the source and target files.`
    },
    'engine': {
      type: 'string',
      default: 'nunjunks',
      description: `Template engine being used.`
    },
    'from': {
      oneOf: [
        {
          type: 'string'
        },
        {
          instanceof: 'RegExp'
        }
      ],
      description: `Name of the marker from where the content will be replaced.`
    },
    'gid': {
      oneOf: [
        {
          type: 'string'
        },
        {
          type: 'number'
        }
      ],
      description: `File group name or group id.`
    },
    'local': {
      type: 'boolean',
      default: false,
      description: `Treat the source as local instead of remote, only apply with "ssh"
option.`
    },
    'match': {
      oneOf: [
        {
          type: 'string'
        },
        {
          instanceof: 'RegExp'
        }
      ],
      description: `Replace this marker, default to the replaced string if missing.`
    },
    'mode': {
      type: 'integer',
      description: `File mode (permission and sticky bits), default to \`0o0644\`, in the
form of \`{mode: 0o0744}\` or \`{mode: "0744"}\`.`
    },
    'place_before': {
      oneOf: [
        {
          type: 'string'
        },
        {
          type: 'boolean'
        },
        {
          instanceof: 'RegExp'
        }
      ],
      description: `Place the content before the match.`
    },
    'remove_empty_lines': {
      type: 'boolean',
      description: `Remove empty lines from content`
    },
    'replace': {
      oneOf: [
        {
          type: 'string'
        },
        {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      ],
      description: `The content to be inserted, used conjointly with the from, to or match
options.`
    },
    'source': {
      type: 'string',
      description: `File path from where to extract the content, do not use conjointly
with content.`
    },
    'target': {
      oneOf: [
        {
          type: 'string'
        },
        {
          typeof: 'function'
        }
      ],
      description: `File path where to write content to. Pass the content `
    },
    'to': {
      oneOf: [
        {
          type: 'string'
        },
        {
          instanceof: 'RegExp'
        }
      ],
      description: `Name of the marker until where the content will be replaced.`
    },
    'uid': {
      oneOf: [
        {
          type: 'string'
        },
        {
          type: 'number'
        }
      ],
      description: `File user name or user id.`
    },
    'unlink': {
      type: 'boolean',
      default: false,
      description: `Replace the existing link, leaving the refered file untouched.`
    },
    'write': {
      description: `An array containing multiple transformation where a transformation is
an object accepting the options \`from\`, \`to\`, \`match\` and \`replace\`.`,
      type: 'array',
      items: {
        type: 'object',
        properties: {
          'from': {
            oneOf: [
              {
                type: 'string'
              },
              {
                instanceof: 'RegExp'
              }
            ],
            description: `File path from where to extract the content, do not use conjointly
with content.`
          },
          'to': {
            oneOf: [
              {
                type: 'string'
              },
              {
                instanceof: 'RegExp'
              }
            ],
            description: `Name of the marker until where the content will be replaced.`
          },
          'match': {
            oneOf: [
              {
                type: 'string'
              },
              {
                instanceof: 'RegExp'
              }
            ],
            description: `Replace this marker, default to the replaced string if missing.`
          },
          'replace': {
            type: 'string',
            description: `The content to be inserted, used conjointly with the from, to or match
options.`
          }
        }
      }
    }
  }
};

// ## Handler
handler = async function({
    config,
    log,
    metadata,
    operations: {status},
    ssh
  }) {
  return ({status} = (await this.call(async function() {
    var contentChanged, context, err, exists, j, len, ref, source, stats, target, targetContentHash, w;
    this.log({
      message: "Entering file",
      level: 'DEBUG',
      module: 'nikita/lib/file'
    });
    // Content: pass all arguments to function calls
    context = arguments[0];
    this.log({
      message: `Source is \"${config.source}\"`,
      level: 'DEBUG',
      module: 'nikita/lib/file'
    });
    this.log({
      message: `Destination is \"${config.target}\"`,
      level: 'DEBUG',
      module: 'nikita/lib/file'
    });
    if (typeof config.content === 'function') {
      config.content = config.content.call(this, context);
    }
    if (config.diff == null) {
      config.diff = config.diff || !!config.stdout;
    }
    // config.engine ?= 'nunjunks'
    // config.unlink ?= false
    // config.encoding ?= 'utf8'
    switch (config.eof) {
      case 'unix':
        config.eof = "\n";
        break;
      case 'mac':
        config.eof = "\r";
        break;
      case 'windows':
        config.eof = "\r\n";
        break;
      case 'unicode':
        config.eof = "\u2028";
    }
    target = null;
    targetContentHash = null;
    if (config.write == null) {
      config.write = [];
    }
    if ((config.from != null) || (config.to != null) || (config.match != null) || (config.replace != null) || (config.place_before != null)) {
      config.write.push({
        from: config.from,
        to: config.to,
        match: config.match,
        replace: config.replace,
        append: config.append,
        place_before: config.place_before
      });
      config.append = false;
    }
    ref = config.write;
    for (j = 0, len = ref.length; j < len; j++) {
      w = ref[j];
      if ((w.from == null) && (w.to == null) && (w.match == null) && (w.replace != null)) {
        w.match = w.replace;
      }
    }
    // Start work
    if (config.source != null) {
      // Option "local" force to bypass the ssh
      // connection, use by the upload function
      source = config.source || config.target;
      this.log({
        message: `Force local source is \"${config.local ? 'true' : 'false'}\"`,
        level: 'DEBUG',
        module: 'nikita/lib/file'
      });
      exists = (await this.fs.base.exists({
        // Invalid arguments: argument 0 is invalid, got false
        ssh: config.local ? false : config.ssh,
        sudo: config.local ? false : config.sudo,
        target: source
      }));
      if (!exists) {
        if (config.source) {
          throw Error(`Source does not exist: ${JSON.stringify(config.source)}`);
        }
        config.content = '';
      }
      this.log({
        message: "Reading source",
        level: 'DEBUG',
        module: 'nikita/lib/file'
      });
      config.content = (await this.fs.base.readFile({
        ssh: config.local ? false : config.ssh,
        sudo: config.local ? false : config.sudo,
        target: source,
        encoding: config.encoding
      }));
    } else if (config.content == null) {
      try {
        config.content = (await this.fs.base.readFile({
          ssh: config.local ? false : config.ssh,
          sudo: config.local ? false : config.sudo,
          target: config.target,
          encoding: config.encoding
        }));
      } catch (error) {
        err = error;
        if (err.code !== 'NIKITA_FS_CRS_TARGET_ENOENT') {
          throw err;
        }
        config.content = '';
      }
    }
    // Stat the target
    stats = (await this.call({
      raw_output: true
    }, async function({}, callback) {
      if (typeof config.target !== 'function') {
        this.log({
          message: "Stat target",
          level: 'DEBUG',
          module: 'nikita/lib/file'
        });
        try {
          ({stats} = (await this.fs.base.lstat({
            target: config.target
          })));
          if (utils.stats.isDirectory(stats.mode)) {
            throw Error('Incoherent situation, target is a directory and there is no source to guess the filename');
            config.target = `${config.target}/${path.basename(config.source)}`;
            this.log({
              message: "Destination is a directory and is now \"config.target\"",
              level: 'INFO',
              module: 'nikita/lib/file'
            });
            // Destination is the parent directory, let's see if the file exist inside
            ({stats} = (await this.fs.base.stat({
              target: config.target,
              relax: 'NIKITA_FS_STAT_TARGET_ENOENT'
            })));
            if (!utils.stats.isFile(stats.mode)) {
              throw Error(`Destination is not a file: ${config.target}`);
            }
            this.log({
              message: "New target exists",
              level: 'INFO',
              module: 'nikita/lib/file'
            });
          } else if (utils.stats.isSymbolicLink(stats.mode)) {
            this.log({
              message: "Destination is a symlink",
              level: 'INFO',
              module: 'nikita/lib/file'
            });
            if (config.unlink) {
              this.fs.base.unlink({
                target: config.target
              });
              stats = null;
            }
          } else if (utils.stats.isFile(stats.mode)) {
            this.log({
              message: "Destination is a file",
              level: 'INFO',
              module: 'nikita/lib/file'
            });
          } else {
            throw Error(`Invalid File Type Destination: ${config.target}`);
          }
          return stats;
        } catch (error) {
          err = error;
          switch (err.code) {
            case 'NIKITA_FS_STAT_TARGET_ENOENT':
              await this.fs.mkdir({
                target: path.dirname(config.target),
                uid: config.uid,
                gid: config.gid,
                // force execution right on mkdir
                mode: config.mode ? config.mode | 0o111 : 0o755
              });
              break;
            default:
              throw err;
          }
          return null;
        }
      }
    }));
    //### need utils.string.render for this
    // @call  -> # render
    //   utils.string.render.call @, config if config.context?
    this.call(function() { // remove_empty_lines
      if (config.remove_empty_lines == null) {
        return;
      }
      this.log({
        message: "Remove empty lines",
        level: 'DEBUG',
        module: 'nikita/lib/file'
      });
      return config.content = config.content.replace(/(\r\n|[\n\r\u0085\u2028\u2029])\s*(\r\n|[\n\r\u0085\u2028\u2029])/g, "$1");
    });
    this.call(function() { // replace_partial
      if (config.write.length) {
        return utils.string.replace_partial.call(this, config);
      }
    });
    this.call(function() { // eof
      var char, i, k, len1, ref1;
      if (config.eof == null) {
        return;
      }
      this.log({
        message: 'Checking option eof',
        level: 'DEBUG',
        module: 'nikita/lib/file'
      });
      if (config.eof === true) {
        ref1 = config.content;
        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
          char = ref1[i];
          if (char === '\r') {
            config.eof = config.content[i + 1] === '\n' ? '\r\n' : char;
            break;
          }
          if (char === '\n' || char === '\u2028') {
            config.eof = char;
            break;
          }
        }
        if (config.eof === true) {
          config.eof = '\n';
        }
        this.log({
          message: `Option eof is true, guessing as ${JSON.stringify(config.eof)}`,
          level: 'INFO',
          module: 'nikita/lib/file'
        });
      }
      if (!utils.string.endsWith(config.content, config.eof)) {
        this.log({
          message: 'Add eof',
          level: 'INFO',
          module: 'nikita/lib/file'
        });
        return config.content += config.eof;
      }
    });
    await this.call(async function() { // diff
      var ref1, targetContent;
      targetContent = (await this.fs.base.readFile({
        target: config.target,
        encoding: config.encoding,
        relax: 'NIKITA_FS_CRS_TARGET_ENOENT'
      }));
      if (((ref1 = targetContent.error) != null ? ref1.code : void 0) === 'NIKITA_FS_CRS_TARGET_ENOENT') {
        return true;
      }
      targetContentHash = utils.string.hash(targetContent);
      // {raw, text} = diff targetContent, config.content, config
      // config.diff text, raw if typeof config.diff is 'function'
      // @log message: text, type: 'diff', level: 'INFO', module: 'nikita/lib/file'
      return false;
    });
    if (config.content != null) {
      contentChanged = (stats == null) || targetContentHash !== utils.string.hash(config.content);
    }
    await this.call(function() { // backup
      var backup;
      if (!(config.backup && contentChanged)) {
        return;
      }
      this.log({
        message: "Create backup",
        level: 'INFO',
        module: 'nikita/lib/file'
      });
      if (config.backup_mode == null) {
        config.backup_mode = 0o0400;
      }
      backup = typeof config.backup === 'string' ? config.backup : `.${Date.now()}`;
      return this.fs.copy({
        source: config.target,
        target: `${config.target}${backup}`,
        mode: config.backup_mode,
        relax: 'NIKITA_FS_STAT_TARGET_ENOENT'
      });
    });
    // Ownership and permission are also handled
    // Preserved the file mode if the file exists. Otherwise,
    // delegate to fs.createWriteStream` the creation of the default
    // mode of "744".
    if (typeof config.target === 'function') {
      this.log({
        message: 'Write target with user function',
        level: 'INFO',
        module: 'nikita/lib/file'
      });
      config.target({
        content: config.content,
        status: contentChanged
      });
    } else {
      // https://github.com/nodejs/node/issues/1104
      // `mode` specifies the permissions to use in case a new file is created.
      if (contentChanged) {
        this.call(function() {
          if (config.append) {
            if (config.flags == null) {
              config.flags = 'a';
            }
          }
          this.fs.base.writeFile({
            target: config.target,
            flags: config.flags,
            content: config.content,
            mode: stats != null ? stats.mode : void 0
          });
          return {
            status: true
          };
        });
      }
      if (config.mode) {
        this.fs.chmod({
          target: config.target,
          stats: stats,
          mode: config.mode
        });
      } else {
        this.fs.chmod({
          target: config.target,
          stats: stats,
          mode: stats != null ? stats.mode : void 0,
          if: stats
        });
      }
      // Option gid is set at runtime if target is a new file
      this.fs.chown({
        target: config.target,
        stats: stats,
        uid: config.uid,
        gid: config.gid,
        if: (config.uid != null) || (config.gid != null)
      });
    }
    return {};
  })));
};

// ## Exports
module.exports = {
  handler: handler,
  hooks: {
    on_action: on_action
  },
  schema: schema
};

// ## Dependencies
path = require('path');

utils = require('@nikitajs/engine/src/utils');

// diff = require './utils/diff'
// string = require '@nikitajs/engine/src/utils/string'

// [diffLines]: https://github.com/kpdecker/jsdiff
